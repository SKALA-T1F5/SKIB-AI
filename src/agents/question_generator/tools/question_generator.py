"""
ÏßàÎ¨∏ ÏÉùÏÑ± ÎèÑÍµ¨
- GPT-4 VisionÏùÑ ÏÇ¨Ïö©Ìïú ÏûêÎèô ÏßàÎ¨∏ ÏÉùÏÑ±
- Î∏îÎ°ùÏùÑ Vision APIÏö© Ï≤≠ÌÅ¨Î°ú Î≥ÄÌôò
- Í∞ùÍ¥ÄÏãù/Ï£ºÍ¥ÄÏãù Î¨∏Ï†ú ÏÉùÏÑ±
"""

import base64
import json
import os
from typing import Dict, List

import google.generativeai as genai
from dotenv import load_dotenv

from .prompt import get_vision_prompt

# ÌôòÍ≤Ω Î≥ÄÏàò Î°úÎìú
load_dotenv(override=True)
gemini_api_key = os.getenv("GEMINI_API_KEY")
genai.configure(api_key=gemini_api_key)


def generate_question(
    messages: List[Dict],
    source: str,
    page: str,
    num_objective: int = 1,
    num_subjective: int = 1,
    difficulty: str = "NORMAL",
) -> List[Dict]:
    """
    Gemini 2.5 ProÎ•º ÏÇ¨Ïö©ÌïòÏó¨ ÏßàÎ¨∏ÏùÑ ÏÉùÏÑ±ÌïòÎäî Ìï®Ïàò

    Args:
        messages: Vision API Î©îÏãúÏßÄ Î∞∞Ïó¥ (ÌÖçÏä§Ìä∏ Î∞è Ïù¥ÎØ∏ÏßÄ Ìè¨Ìï®)
        source: Î¨∏ÏÑú ÏÜåÏä§ ÌååÏùºÎ™Ö
        page: ÌéòÏù¥ÏßÄ Î≤àÌò∏
        num_objective: Í∞ùÍ¥ÄÏãù Î¨∏Ï†ú Ïàò
        num_subjective: Ï£ºÍ¥ÄÏãù Î¨∏Ï†ú Ïàò
        difficulty: ÎÇúÏù¥ÎèÑ (EASY, NORMAL, HARD)

    Returns:
        List[Dict]: ÏÉùÏÑ±Îêú ÏßàÎ¨∏ Î™©Î°ù
    """
    try:
        # Vision APIÏö© ÌîÑÎ°¨ÌîÑÌä∏ ÏÉùÏÑ±
        system_prompt = get_vision_prompt(
            source, page, difficulty, num_objective, num_subjective
        )

        print(
            f"  ü§ñ Gemini 2.5 Pro Ìò∏Ï∂ú Ï§ë... (Í∞ùÍ¥ÄÏãù: {num_objective}, Ï£ºÍ¥ÄÏãù: {num_subjective})"
        )

        # Gemini 2.5 Pro Î™®Îç∏ Ï¥àÍ∏∞Ìôî (ÏïàÏ†Ñ ÏÑ§Ï†ï ÏôÑÌôî)
        safety_settings = [
            {"category": "HARM_CATEGORY_HARASSMENT", "threshold": "BLOCK_NONE"},
            {"category": "HARM_CATEGORY_HATE_SPEECH", "threshold": "BLOCK_NONE"},
            {"category": "HARM_CATEGORY_SEXUALLY_EXPLICIT", "threshold": "BLOCK_NONE"},
            {"category": "HARM_CATEGORY_DANGEROUS_CONTENT", "threshold": "BLOCK_NONE"},
        ]

        model = genai.GenerativeModel("gemini-2.5-pro", safety_settings=safety_settings)

        # GeminiÏö© Î©îÏãúÏßÄ Íµ¨ÏÑ±
        gemini_parts = [system_prompt]

        for message in messages:
            if message.get("type") == "text":
                gemini_parts.append(message["text"])
            elif message.get("type") == "image_url":
                import io

                from PIL import Image

                image_url = message["image_url"]["url"]
                if image_url.startswith("data:image"):
                    base64_data = image_url.split(",")[1]
                    image_data = base64.b64decode(base64_data)
                    image = Image.open(io.BytesIO(image_data))
                    gemini_parts.append(image)

        # Gemini API Ìò∏Ï∂ú
        response = model.generate_content(
            gemini_parts,
            generation_config=genai.types.GenerationConfig(
                temperature=0.7,
                max_output_tokens=2000,
            ),
        )

        # ÏïàÏ†ÑÌïú ÏùëÎãµ Ï≤òÎ¶¨
        if response.candidates and response.candidates[0].content.parts:
            raw_content = response.text.strip()
            print(f"  üìÑ ÏùëÎãµ ÎÇ¥Ïö© ÎØ∏Î¶¨Î≥¥Í∏∞: {raw_content[:100]}...")
        else:
            print(
                f"  ‚ö†Ô∏è Gemini ÏùëÎãµÏù¥ Ï∞®Îã®Îê® (finish_reason: {response.candidates[0].finish_reason if response.candidates else 'N/A'})"
            )
            return []

        # JSON ÌååÏã±
        try:
            # ÏΩîÎìú Î∏îÎ°ù Ï†úÍ±∞
            if "```json" in raw_content:
                raw_content = raw_content.split("```json")[1].split("```")[0].strip()
            elif "```" in raw_content:
                raw_content = raw_content.split("```")[1].split("```")[0].strip()

            # JSONÏù¥ ÏûòÎ¶∞ Í≤ΩÏö∞ Î≥µÍµ¨ ÏãúÎèÑ
            if not raw_content.strip().endswith("]"):
                # Î∞∞Ïó¥Ïù¥ ÏôÑÎ£åÎêòÏßÄ ÏïäÏùÄ Í≤ΩÏö∞, ÎßàÏßÄÎßâ Í∞ùÏ≤¥ Ï†úÍ±∞
                if raw_content.strip().endswith(","):
                    raw_content = raw_content.strip()[:-1]

                # Î∂àÏôÑÏ†ÑÌïú ÎßàÏßÄÎßâ Í∞ùÏ≤¥ Ï†úÍ±∞
                bracket_count = 0
                valid_end = -1
                for i, char in enumerate(raw_content):
                    if char == "{":
                        bracket_count += 1
                    elif char == "}":
                        bracket_count -= 1
                        if bracket_count == 0:
                            valid_end = i

                if valid_end > 0:
                    raw_content = raw_content[: valid_end + 1] + "]"
                else:
                    raw_content += "]"

            questions = json.loads(raw_content)

            # Î¶¨Ïä§Ìä∏Ïù∏ÏßÄ ÌôïÏù∏
            if not isinstance(questions, list):
                print(f"‚ö†Ô∏è ÏùëÎãµÏù¥ Î¶¨Ïä§Ìä∏Í∞Ä ÏïÑÎãôÎãàÎã§: {type(questions)}")
                return []

            print(f"  ‚úÖ {len(questions)}Í∞ú ÏßàÎ¨∏ ÌååÏã± ÏÑ±Í≥µ")
            return questions

        except json.JSONDecodeError as e:
            print(f"  ‚ùå JSON ÌååÏã± Ïã§Ìå®: {e}")
            print(f"  ÏõêÎ≥∏ ÏùëÎãµ Í∏∏Ïù¥: {len(raw_content)} Î¨∏Ïûê")
            print(f"  ÏùëÎãµ ÎßàÏßÄÎßâ 100Ïûê: ...{raw_content[-100:]}")
            return []

    except Exception as e:
        print(f"  ‚ùå ÏßàÎ¨∏ ÏÉùÏÑ± Ïã§Ìå®: {e}")
        import traceback

        print(f"  üìÑ ÏÉÅÏÑ∏ Ïò§Î•ò: {traceback.format_exc()}")
        return []


# Í∏∞Ï°¥ Gemini Î≤ÑÏ†Ñ (Ï£ºÏÑù Ï≤òÎ¶¨)
"""
def generate_question_gemini(
    messages: List[Dict], 
    source: str, 
    page: str, 
    num_objective: int = 1, 
    num_subjective: int = 1,
    difficulty: str = "NORMAL"
) -> List[Dict]:
    try:
        system_prompt = get_vision_prompt(source, page, difficulty, num_objective, num_subjective)

        print(f"  ü§ñ Gemini 2.5 Flash Ìò∏Ï∂ú Ï§ë... (Í∞ùÍ¥ÄÏãù: {num_objective}, Ï£ºÍ¥ÄÏãù: {num_subjective})")

        model = genai.GenerativeModel('gemini-2.0-flash-exp')

        gemini_parts = []
        gemini_parts.append(system_prompt)

        for message in messages:
            if message.get("type") == "text":
                gemini_parts.append(message["text"])
            elif message.get("type") == "image_url":
                import io
                from PIL import Image

                image_url = message["image_url"]["url"]
                if image_url.startswith("data:image"):
                    base64_data = image_url.split(",")[1]
                    image_data = base64.b64decode(base64_data)
                    image = Image.open(io.BytesIO(image_data))
                    gemini_parts.append(image)

        response = model.generate_content(
            gemini_parts,
            generation_config=genai.types.GenerationConfig(
                temperature=0.7,
                max_output_tokens=2000,
            )
        )

        raw_content = response.text.strip()

        if "```json" in raw_content:
            raw_content = raw_content.split("```json")[1].split("```")[0].strip()
        elif "```" in raw_content:
            raw_content = raw_content.split("```")[1].split("```")[0].strip()

        questions = json.loads(raw_content)

        if not isinstance(questions, list):
            return []

        return questions
    except Exception as e:
        print(f"  ‚ùå ÏßàÎ¨∏ ÏÉùÏÑ± Ïã§Ìå®: {e}")
        return []
"""


class QuestionGenerator:
    """ÏßàÎ¨∏ ÏÉùÏÑ± ÌÅ¥ÎûòÏä§"""

    def __init__(self, image_save_dir: str = "data/images"):
        """
        QuestionGenerator Ï¥àÍ∏∞Ìôî

        Args:
            image_save_dir: Ïù¥ÎØ∏ÏßÄ ÌååÏùºÏù¥ Ï†ÄÏû•Îêú ÎîîÎ†âÌÜ†Î¶¨ Í≤ΩÎ°ú
        """
        self.image_save_dir = image_save_dir

    def generate_questions_for_blocks(
        self, blocks: List[Dict], num_objective: int = 3, num_subjective: int = 3
    ) -> List[Dict]:
        """
        Î∏îÎ°ùÎì§Ïóê ÎåÄÌï¥ GPT-4 VisionÏúºÎ°ú ÏßàÎ¨∏ ÏÉùÏÑ±

        Args:
            blocks: Î¨∏ÏÑú Î∏îÎ°ùÎì§
            num_objective: Í∞ùÍ¥ÄÏãù Î¨∏Ï†ú Ïàò
            num_subjective: Ï£ºÍ¥ÄÏãù Î¨∏Ï†ú Ïàò

        Returns:
            List[Dict]: ÏßàÎ¨∏Ïù¥ Ï∂îÍ∞ÄÎêú Î∏îÎ°ùÎì§
        """
        print("ü§ñ Gemini 2.5 Pro ÏßàÎ¨∏ ÏÉùÏÑ± Ï§ë...")

        try:
            # Î∏îÎ°ùÎì§ÏùÑ Ï≤≠ÌÇπÌïòÏó¨ Gemini 2.5 Pro Î©îÏãúÏßÄ ÏÉùÏÑ±
            vision_chunks = self._blocks_to_vision_chunks(blocks)

            questions_generated = 0
            total_questions_target = num_objective + num_subjective

            for i, chunk in enumerate(vision_chunks):
                if questions_generated >= total_questions_target:
                    break

                print(f"  üìù Ï≤≠ÌÅ¨ {i+1}/{len(vision_chunks)} ÏßàÎ¨∏ ÏÉùÏÑ± Ï§ë...")

                # ÎÇ®ÏùÄ ÏßàÎ¨∏ Ïàò Í≥ÑÏÇ∞
                remaining_obj = max(
                    0,
                    num_objective
                    - len(
                        [
                            q
                            for b in blocks
                            for q in b.get("questions", [])
                            if q.get("type") == "OBJECTIVE"
                        ]
                    ),
                )
                remaining_subj = max(
                    0,
                    num_subjective
                    - len(
                        [
                            q
                            for b in blocks
                            for q in b.get("questions", [])
                            if q.get("type") == "SUBJECTIVE"
                        ]
                    ),
                )

                if remaining_obj == 0 and remaining_subj == 0:
                    break

                # Ï≤≠ÌÅ¨Î≥Ñ ÏßàÎ¨∏ Ïàò Î∂ÑÎ∞∞
                chunk_obj = min(
                    remaining_obj, max(1, remaining_obj // (len(vision_chunks) - i))
                )
                chunk_subj = min(
                    remaining_subj, max(1, remaining_subj // (len(vision_chunks) - i))
                )

                if chunk_obj == 0 and chunk_subj == 0:
                    continue

                try:
                    # Gemini 2.5 ProÎ°ú ÏßàÎ¨∏ ÏÉùÏÑ± (ÌÇ§ÏõåÎìúÏôÄ Ï£ºÏ†ú ÌôúÏö©)
                    questions = generate_question(
                        messages=chunk["messages"],
                        source=chunk["metadata"].get("source", "unknown"),
                        page=str(chunk["metadata"].get("page", "N/A")),
                        num_objective=chunk_obj,
                        num_subjective=chunk_subj,
                    )

                    # Ï≤´ Î≤àÏß∏ Î∏îÎ°ùÏóê ÏßàÎ¨∏ Ï∂îÍ∞Ä (Ï≤≠ÌÅ¨ ÎåÄÌëú)
                    if chunk["block_indices"] and questions:
                        first_block_idx = chunk["block_indices"][0]
                        if "questions" not in blocks[first_block_idx]:
                            blocks[first_block_idx]["questions"] = []
                        blocks[first_block_idx]["questions"].extend(questions)
                        questions_generated += len(questions)

                        print(f"    ‚úÖ {len(questions)}Í∞ú ÏßàÎ¨∏ ÏÉùÏÑ±")

                except Exception as e:
                    print(f"    ‚ö†Ô∏è Ï≤≠ÌÅ¨ {i+1} ÏßàÎ¨∏ ÏÉùÏÑ± Ïã§Ìå®: {e}")
                    continue

            total_generated = sum(len(b.get("questions", [])) for b in blocks)
            print(f"‚úÖ Ï¥ù {total_generated}Í∞ú ÏßàÎ¨∏ ÏÉùÏÑ± ÏôÑÎ£å")

        except Exception as e:
            print(f"‚ùå ÏßàÎ¨∏ ÏÉùÏÑ± Ï§ë Ïò§Î•ò: {e}")

        return blocks

    def _blocks_to_vision_chunks(
        self, blocks: List[Dict], max_chunk_size: int = 15000
    ) -> List[Dict]:
        """Î∏îÎ°ùÎì§ÏùÑ Gemini 2.5 Pro APIÏö© Ï≤≠ÌÅ¨Î°ú Î≥ÄÌôò"""
        chunks = []
        current_chunk = {
            "messages": [],
            "metadata": {"pages": set(), "source": "document_analyzer"},
            "block_indices": [],
            "current_length": 0,
        }

        def save_current_chunk():
            if current_chunk["messages"]:
                final_metadata = current_chunk["metadata"].copy()
                final_metadata["pages"] = sorted(list(final_metadata["pages"]))
                final_metadata["page"] = (
                    final_metadata["pages"][0] if final_metadata["pages"] else 1
                )

                chunks.append(
                    {
                        "messages": current_chunk["messages"].copy(),
                        "metadata": final_metadata,
                        "block_indices": current_chunk["block_indices"].copy(),
                    }
                )

            current_chunk["messages"].clear()
            current_chunk["metadata"] = {"pages": set(), "source": "document_analyzer"}
            current_chunk["block_indices"].clear()
            current_chunk["current_length"] = 0

        for block_idx, block in enumerate(blocks):
            block_type = block.get("type", "unknown")
            content = block.get("content", "")
            metadata = block.get("metadata", {})
            page_no = metadata.get("page", 1)

            # Î∏îÎ°ùÏùÑ Î©îÏãúÏßÄÎ°ú Î≥ÄÌôò
            message_content = None
            text_length = 0

            if block_type in ["paragraph", "heading", "section"]:
                text_content = str(content) if content else ""
                if text_content.strip():
                    if block_type == "heading":
                        text_content = f"# {text_content}"
                    elif block_type == "section":
                        text_content = f"## {text_content}"

                    message_content = {"type": "text", "text": text_content}
                    text_length = len(text_content)

            elif block_type == "table":
                # ÌëúÎ•º ÌÖçÏä§Ìä∏Î°ú Î≥ÄÌôò
                if isinstance(content, dict) and "data" in content:
                    table_text = self._format_table_as_text(content)
                    message_content = {"type": "text", "text": f"[Table]\n{table_text}"}
                    text_length = len(table_text)

            elif block_type == "image":
                # Ïù¥ÎØ∏ÏßÄ ÌååÏùº ÏùΩÍ∏∞
                image_path = os.path.join(self.image_save_dir, block.get("path", ""))
                if os.path.exists(image_path):
                    try:
                        with open(image_path, "rb") as f:
                            encoded = base64.b64encode(f.read()).decode("utf-8")
                        message_content = {
                            "type": "image_url",
                            "image_url": {"url": f"data:image/png;base64,{encoded}"},
                        }
                        text_length = 1000  # Ïù¥ÎØ∏ÏßÄÎäî Í≥†Ï†ï Í∏∏Ïù¥Î°ú Í≥ÑÏÇ∞
                    except Exception as e:
                        print(f"Ïù¥ÎØ∏ÏßÄ ÏùΩÍ∏∞ Ïã§Ìå® {image_path}: {e}")
                        continue

            # Ï≤≠ÌÅ¨ ÌÅ¨Í∏∞ ÌôïÏù∏ Î∞è Ï†ÄÏû•
            if message_content:
                if (
                    current_chunk["current_length"] + text_length > max_chunk_size
                    and current_chunk["messages"]
                ):
                    save_current_chunk()

                current_chunk["messages"].append(message_content)
                current_chunk["metadata"]["pages"].add(page_no)
                current_chunk["block_indices"].append(block_idx)
                current_chunk["current_length"] += text_length

        # ÎßàÏßÄÎßâ Ï≤≠ÌÅ¨ Ï†ÄÏû•
        save_current_chunk()

        return chunks

    def _format_table_as_text(self, table_data: Dict) -> str:
        """Ìëú Îç∞Ïù¥ÌÑ∞Î•º ÌÖçÏä§Ìä∏Î°ú Î≥ÄÌôò"""
        if not isinstance(table_data, dict) or "data" not in table_data:
            return str(table_data)

        headers = table_data.get("headers", [])
        data = table_data.get("data", [])

        if not data:
            return ""

        table_str = ""
        if headers:
            table_str += " | ".join(str(h) for h in headers) + "\n"
            table_str += "|" + "|".join([":---:"] * len(headers)) + "|\n"

        for row in data:
            table_str += " | ".join(str(cell) for cell in row) + "\n"

        return table_str.strip()


def generate_questions_for_document(
    blocks: List[Dict],
    image_save_dir: str = "data/images",
    num_objective: int = 3,
    num_subjective: int = 3,
) -> List[Dict]:
    """
    Ìé∏Ïùò Ìï®Ïàò: Î¨∏ÏÑú Î∏îÎ°ùÎì§Ïóê ÎåÄÌï¥ ÏßàÎ¨∏ ÏÉùÏÑ±

    Args:
        blocks: Î¨∏ÏÑú Î∏îÎ°ùÎì§
        image_save_dir: Ïù¥ÎØ∏ÏßÄ Ï†ÄÏû• ÎîîÎ†âÌÜ†Î¶¨
        num_objective: Í∞ùÍ¥ÄÏãù Î¨∏Ï†ú Ïàò
        num_subjective: Ï£ºÍ¥ÄÏãù Î¨∏Ï†ú Ïàò

    Returns:
        List[Dict]: ÏßàÎ¨∏Ïù¥ Ï∂îÍ∞ÄÎêú Î∏îÎ°ùÎì§
    """
    generator = QuestionGenerator(image_save_dir)
    return generator.generate_questions_for_blocks(
        blocks, num_objective, num_subjective
    )
